import Mathlib.Tactic.Common
import Mathlib.Data.Set.Basic

namespace CSE290Q

/-!
# The algebraic hierarchy and subobjects

Last time we looked at using typeclasses to implement "by abuse of notation"
for the algebraic hierarchy.

There are two big topics still for algebra:
- How do you make subobjects?
  (Subgroups, subrings, etc.)
- How do you make a hierarchy of homomorphisms?
  (A ring homomorphism *is* a multiplicative homomorphism,
  but this takes some effort in Lean.)

Let's start by looking at the algebraic hierarchy.
(Note: I did not verify that all the axioms are present!)
-/

class One (α : Type u) where
  one : α

instance {α : Type _} [One α] : OfNat α 1 where
  ofNat := One.one

class Semigroup (α : Type u) extends Mul α where
  mul_assoc (a b c : α) : a * b * c = a * (b * c)

class CommSemigroup (α : Type u) extends Semigroup α where
  mul_comm (a b : α) : a * b = b * a

class Monoid (α : Type u) extends Semigroup α, One α where
  one_mul (a : α) : 1 * a = a
  mul_one (a : α) : a * 1 = a

class CommMonoid (α : Type u) extends Monoid α, CommSemigroup α

class Inv (α : Type u) where
  inv : α → α

postfix:100 "⁻¹" => Inv.inv

class Group (α : Type u) extends Monoid α, Inv α where
  mul_left_inv (a : α) : a⁻¹ * a = 1

class CommGroup (α : Type u) extends Group α, CommMonoid α

class AddSemigroup (α : Type u) extends Add α where
  add_assoc (a b c : α) : a + b + c = a + (b + c)

class AddCommSemigroup (α : Type u) extends AddSemigroup α where
  add_comm (a b : α) : a + b = b + a

class AddMonoid (α : Type u) extends AddSemigroup α, Zero α where
  zero_add (a : α) : 0 + a = a
  add_zero (a : α) : a + 0 = a

class AddCommMonoid (α : Type u) extends AddMonoid α, AddCommSemigroup α

class AddGroup (α : Type u) extends AddMonoid α, Neg α where
  add_left_neg (a : α) : -a + a = 0

class AddCommGroup (α : Type u) extends AddGroup α, AddCommMonoid α

class Distrib (α : Type u) extends Mul α, Add α where
  left_distrib ( a b c : α) : a * (b + c) = (a * b) + (a * c)
  right_distrib (a b c : α) : (a + b) * c = (a * c) + (b * c)

class MulZero (α : Type u) extends Mul α, Zero α where
  zero_mul (a : α) : 0 * a = 0
  mul_zero (a : α) : a * 0 = 0

class ZeroNeOne (α : Type u) extends Zero α, One α where
  zero_ne_one : (0:α) ≠ 1

class Semiring (α : Type u) extends AddCommMonoid α, Monoid α, Distrib α, MulZero α

class CommSemiring (α : Type u) extends Semiring α, CommMonoid α

class Ring (α : Type u) extends AddCommGroup α, Monoid α, Distrib α

class CommRing (α : Type u) extends Ring α, CommSemigroup α

class NoZeroDivisors (α : Type u) extends Mul α, Zero α where
  eq_zero_or_eq_zero_of_mul_eq_zero (a b : α) : a * b = 0 → a = 0 ∨ b = 0

class IntegralDomain (α : Type u) extends CommRing α, NoZeroDivisors α, ZeroNeOne α

class DivisionRing (α : Type u) extends Ring α, Inv α, ZeroNeOne α where
  mul_inv_cancel {a : α} : a ≠ 0 → a * a⁻¹ = 1
  inv_mul_cancel {a : α} : a ≠ 0 → a⁻¹ * a = 1

class Field (α : Type u) extends DivisionRing α, CommRing α

#print Field

/-!
How do we design subobjects?

What do we want?
- A submonoid should "be" a set.
- A submonoid should "be" a monoid.
- A submonoid should "be" a subsemigroup.
- We should have a type of submonoids, since it has a lattice structure
  (infimum is intersection, supremum is submonoid generated by the union).

(Note: mathlib makes use of abstractions like `SetLike` to organize this.
We will do things from scratch.)
-/

/-- Type of subsemigroups. -/
structure Subsemigroup (α : Type u) [Semigroup α] where
  carrier : Set α
  mul_mem' : ∀ {a b : α}, a ∈ carrier → b ∈ carrier → a * b ∈ carrier

section Subsemigroup
variable {α : Type u} [Semigroup α]

/-- Subsemigroup as a set. -/
instance : Membership α (Subsemigroup α) where
  mem s x := x ∈ s.carrier

-- Normalization to this instance.
@[simp]
theorem Subsemigroup.mem_carrier {s : Subsemigroup α} {x : α} :
    x ∈ s.carrier ↔ x ∈ s := Iff.rfl

/-- Restatement in terms of this set operation. -/
@[simp]
theorem Semigroup.mul_mem {s : Subsemigroup α} {a b : α}
    (ha : a ∈ s) (hb : b ∈ s) : a * b ∈ s :=
  s.mul_mem' ha hb

/-- A subsemigroup as a type. -/
instance : CoeSort (Subsemigroup α) (Type u) where
  coe s := { a // a ∈ s } -- `Subtype`

/-- That type as a semigroup. -/
instance {s : Subsemigroup α} : Semigroup s where
  mul := fun a b => ⟨a * b, Semigroup.mul_mem a.2 b.2⟩
  mul_assoc := by
    rintro ⟨a, ha⟩ ⟨b, hb⟩ ⟨c, hc⟩
    rw [← Subtype.coe_inj]
    apply Semigroup.mul_assoc

-- Works!
example (s : Subsemigroup α) (a b c : s) :
    a * b * c = a * (b * c) := by
  rw [Semigroup.mul_assoc]

end Subsemigroup


/-- Type of submonoids. -/
structure Submonoid (α : Type u) [Monoid α] extends Subsemigroup α where
  one_mem' : (1 : α) ∈ carrier

section Submonoid
variable {α : Type u} [Monoid α]

/-- Submonoid as a set. -/
instance : Membership α (Submonoid α) where
  mem s x := x ∈ s.carrier

-- Normalization to this instance.
@[simp]
theorem Submonoid.mem_carrier {s : Submonoid α} {x : α} :
    x ∈ s.carrier ↔ x ∈ s := Iff.rfl

/-- Restatement in terms of this set operation. -/
@[simp]
theorem Submonoid.mul_mem {s : Submonoid α} {a b : α}
    (ha : a ∈ s) (hb : b ∈ s) : a * b ∈ s :=
  s.mul_mem' ha hb

/-- Restatement in terms of this set operation. -/
@[simp]
theorem Submonoid.one_mem {s : Submonoid α} : (1 : α) ∈ s :=
  s.one_mem'

-- Try commenting out the `@[simp]`. This `Submonoid`-specific restatement
-- is unfortunately necessary! We'll see how to design this properly in a bit.
example {s : Submonoid α} {a b : α}
    (ha : a ∈ s) (hb : b ∈ s) : a * b ∈ s := by
  simp [*]

/-- A Submonoid as a type. -/
instance : CoeSort (Submonoid α) (Type u) where
  coe s := { a // a ∈ s } -- `Subtype`

/-- That type as a semigroup. -/
instance {s : Submonoid α} : Monoid s where
  mul := fun a b => ⟨a * b, Submonoid.mul_mem a.2 b.2⟩
  one := ⟨1, by simp⟩
  mul_assoc := by
    rintro ⟨a, ha⟩ ⟨b, hb⟩ ⟨c, hc⟩
    rw [← Subtype.coe_inj]
    apply Semigroup.mul_assoc
  one_mul := by
    rintro ⟨a, ha⟩
    rw [← Subtype.coe_inj]
    apply Monoid.one_mul
  mul_one := by
    rintro ⟨a, ha⟩
    rw [← Subtype.coe_inj]
    apply Monoid.mul_one

-- Works! A `Submonoid` is a `Semigroup`.
example (s : Submonoid α) (a b c : s) :
    a * b * c = a * (b * c) := by
  rw [Semigroup.mul_assoc]

-- Works! A `Submonoid` is a `Monoid`.
example (s : Submonoid α) (a : s) :
    1 * a * 1 = a := by
  rw [Monoid.one_mul, Monoid.mul_one]

end Submonoid

/-!
However, a `Submonoid` is not a `Subsemigroup` exactly.

Let's work out how to design this together.
-/
